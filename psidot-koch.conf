extern double gamm[3][3];
extern double normgamma;
extern double C1, C2, C3;

void compute_psidot_koch(COMPLEX* psidot, COMPLEX* psi) {
  double a4[3][3][3][3], a6[3][3][3][3][3][3];
  int i1,i2,i3,i4,i5,i6;
  double D1, D2[3][3];

  tensor4(psi,a4);
  tensor6(psi,a6);
  D1 = 0;
  for (i1=0;i1<3;i1++) for (i2=0;i2<3;i2++)
    for (i3=0;i3<3;i3++) for (i4=0;i4<3;i4++)
      D1 += a4[i1][i2][i3][i4]*gamm[i1][i2]*gamm[i3][i4]/normgamma;
  for (i1=0;i1<3;i1++) for (i2=0;i2<3;i2++) {
    D2[i1][i2] = 0;
    for (i3=0;i3<3;i3++) for (i4=0;i4<3;i4++)
      for (i5=0;i5<3;i5++) for (i6=0;i6<3;i6++)
        D2[i1][i2] += a6[i1][i2][i3][i4][i5][i6]*gamm[i3][i4]*gamm[i5][i6]/normgamma;
  }

  @spherical_iterate {
    if (C1!=0)
      psidot[@index] += C1*D1*@method(psi,dx*dx+dy*dy+dz*dz);
    if (C2!=0)
      psidot[@index] += C2*(D2[0][0]*@method(psi,(dx-2*x)*dx)
                            + D2[0][1]*@method(psi,(dx-2*x)*dy+(dy-2*y)*dx)
                            + D2[0][2]*@method(psi,(dx-2*x)*dz+(dz-2*z)*dx)
                            + D2[1][1]*@method(psi,(dy-2*y)*dy)
                            + D2[1][2]*@method(psi,(dy-2*y)*dz+(dz-2*z)*dy)
                            + D2[2][2]*@method(psi,(dz-2*z)*dz));
    if (C3!=0)
      psidot[@index] -= C3*(D2[0][0]*@method(psi,lx*lx)
                            + D2[0][1]*@method(psi,lx*ly+ly*lx)
                            + D2[0][2]*@method(psi,lx*lz+lz*lx)
                            + D2[1][1]*@method(psi,ly*ly)
                            + D2[1][2]*@method(psi,ly*lz+lz*ly)
                            + D2[2][2]*@method(psi,lz*lz));
  }
}
