extern double w[3];
extern double gamm[3][3];
extern double lambda1;
extern double lambda2;
extern double Dr;
extern double normgamma;
extern int do_vl;

void compute_psidot_vl(COMPLEX* psidot, COMPLEX* psi) {
  double s;
  double a2[3][3];
  double a4[3][3][3][3];
  double lambda;
  int i1,i2,i3,i4;

  s = 0;
  if (do_vl == 1) {
    tensor2(psi,a2);
    for (i1=0;i1<3;i1++) for (i2=0;i2<3;i2++)
      s += a2[i1][i2]*gamm[i1][i2];
    s = fabs(s)/normgamma;
  } else if (do_vl == 2) {
    tensor4(psi,a4);
    for (i1=0;i1<3;i1++) for (i2=0;i2<3;i2++) for (i3=0;i3<3;i3++) for (i4=0;i4<3;i4++)
      s += a4[i1][i2][i3][i4]*gamm[i1][i2]*gamm[i3][i4];
    s = sqrt(s)/normgamma;
  }
  lambda = lambda1 - lambda2*s;

  @spherical_iterate {
/* Jeffery's Equation */
    psidot[@index] += w[0]*@method(psi,0.5*y*dz-0.5*z*dy)
                      + w[1]*@method(psi,0.5*z*dx-0.5*x*dz)
                      + w[2]*@method(psi,0.5*x*dy-0.5*y*dx)
                      + lambda*gamm[0][0]*@method(psi,0.5*x*dx)
                      + lambda*gamm[0][1]*@method(psi,0.5*x*dy+0.5*y*dx)
                      + lambda*gamm[0][2]*@method(psi,0.5*x*dz+0.5*z*dx)
                      + lambda*gamm[1][1]*@method(psi,0.5*y*dy)
                      + lambda*gamm[1][2]*@method(psi,0.5*y*dz+0.5*z*dy)
                      + lambda*gamm[2][2]*@method(psi,0.5*z*dz)
/* Folgar-Tucker correction */
                      + Dr*@method(psi,dx*dx+dy*dy+dz*dz);
  }
}
